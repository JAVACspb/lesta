# Быстрая сортировка (Quicksort)

## Как я рассудил

В реальных условиях (когда массив действительно случайный, велик по размеру и может находиться в любом порядке)
одним из самых быстрых алгоритмов будет **быстрая сортировка (Quicksort)**

В среднем Quicksort работает за **O(n log n)** и имеет сравнительно низкие константы времени.

**Но**:

- В Java сортировка массивов примитивов через `Arrays.sort()`, а объектов — **Merge Sort**.
- Эти реализации годами оттачивались и конечно будут быстрее любой самодельной функции сортировки.

Так что если смотреть со стороны «минимума CPU-тиков» в реальном приложении, чаще всего самый быстрый способ — это
вызвать встроенную сортировку (`Arrays.sort(...)`) и довериться оптимизации внутри Java.

## Почему быстрая сортировка лучший выбор

1. **Среднее время O(n log n)**.
2. **Минимальная дополнительная память**: Quicksort работает на месте (*in-place*), не требует O(n) дополнительной
   памяти.
3. **Низкая константа во внутренних циклах**: алгоритм деления массива на подмассивы (*partition*) очень прост и
   оптимизируется компилятором.

## Минусы

1. **В худшем случае (когда *pivot* оказывается «неудачным» постоянно) Quicksort работает за O(n^2)**.
2. **Но для действительно случайных данных это маловероятно, особенно при использовании рандомного выбора опорного
   элемента или медианы трёх**.

## Как итог всего выше изложенного, я решил привести в пример упрощенную реализацию
